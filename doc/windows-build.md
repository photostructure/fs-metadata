# Windows Build Issues and Solutions

## Overview

This document summarizes the Windows-specific build issues encountered with fs-metadata, particularly the "No Target Architecture" error from the Windows SDK, and various approaches to resolving it.

## The Core Issue

When building on Windows with node-gyp/prebuildify, we encounter:

```
C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\um\winnt.h(173,1): fatal error C1189: #error:  "No Target Architecture"
```

This error occurs because:

1. The Windows SDK headers require architecture macros (`_M_X64`, `_WIN64`, etc.) to be defined before including `<windows.h>`
2. Node-gyp doesn't always properly pass these defines when using prebuildify
3. The `target_arch` variable in binding.gyp conditions might not be evaluated correctly

## Why This Happens

### Root Cause

- Prebuildify calls node-gyp with `--arch` (previously `--target-arch`)
- The architecture should default to `os.arch()` (which correctly returns `x64` on Windows)
- However, the architecture defines aren't being set properly in the MSVC project generated by node-gyp

### Why Other Projects Don't Have This Issue

Projects like node-sqlite3 don't typically encounter this because:

1. They don't define architecture-specific macros in binding.gyp (these should come from the compiler)
2. They may not be using prebuildify, or are using different build configurations
3. They might be including Windows headers in a different order

## Attempted Solutions

### 1. Architecture Defines in binding.gyp (Not Sufficient)

Attempted to add architecture defines conditionally:

```json
"conditions": [
  [
    "target_arch=='x64'",
    {
      "defines": [
        "_M_X64",
        "_WIN64"
      ]
    }
  ]
]
```

**Result**: Doesn't reliably fix prebuildify builds

### 2. Windows Header Wrapper (Failed)

Created `windows_headers.h` to force architecture defines:

```cpp
#ifndef _M_X64
  #define _M_X64 1
  #define _AMD64_ 1
  #define _WIN64 1
#endif
#include <windows.h>
```

**Result**: Didn't resolve the issue for all files

### 3. Direct Source File Defines (Don't Use - Breaks ARM64)

Adding architecture defines at the top of each Windows source file:

```cpp
// Force architecture defines for Windows SDK
#ifndef _M_X64
  #define _M_X64 1
#endif
#ifndef _AMD64_
  #define _AMD64_ 1
#endif
#ifndef _WIN64
  #define _WIN64 1
#endif
```

**Result**: This hardcodes x64 defines and would break ARM64 builds

### 4. CL Environment Variable (Current Solution)

Created `scripts/prebuildify-wrapper.ts` that sets the `CL` environment variable:

```typescript
if (currentArch === "x64") {
  env.CL = "/D_M_X64 /D_WIN64 /D_AMD64_";
} else if (currentArch === "arm64") {
  env.CL = "/D_M_ARM64 /D_WIN64";
}
```

**Result**: Works correctly for both x64 and ARM64 architectures

## Current Status

### What Works

- Building with the prebuildify wrapper that sets CL environment variable
- This solution properly handles both x64 and ARM64 architectures

### What Doesn't Work

- Relying on node-gyp/prebuildify to properly evaluate binding.gyp conditions
- Direct source file defines (would break ARM64 builds)
- windows_compat.h wrapper (can't distinguish architectures at compile time)

### Debug Builds Removed

- Debug builds have been removed from the project as they provided no value
- Windows debug CRT builds cannot be loaded by Node.js due to missing runtime dependencies
- JavaScript-based memory testing provides adequate leak detection

## Other Important Findings

### Node.js Version Compatibility

- Jest 30 doesn't support Node.js 23
- CI/CD workflows use Node.js 20, 22, and 24
- Removed Node.js 23 from test matrices

### Related Issues

1. **Memory Test Failures**: Initially appeared as "unsupported engine" warnings
2. **Architecture Detection**: `process.arch` correctly returns `x64` on Windows
3. **Prebuildify Defaults**: Should use `os.arch()` and `os.platform()` but something in the chain breaks

## Potential Future Solutions

### 1. Wrapper Script for Prebuildify

Create a TypeScript script to explicitly pass architecture:

```typescript
import { arch, platform } from "os";
import { spawn } from "child_process";

spawn(
  "prebuildify",
  [
    "--napi",
    "--tag-libc",
    "--strip",
    "--arch",
    arch(),
    "--platform",
    platform(),
  ],
  { stdio: "inherit" },
);
```

### 2. Environment Variables

Set architecture explicitly:

```bash
set npm_config_arch=x64
npm run build
```

### 3. Investigation Areas

- Why `target_arch` isn't being evaluated in binding.gyp conditions
- Why prebuildify + node-gyp isn't passing architecture defines to MSVC
- Whether this is a node-gyp bug or a configuration issue

## References

### GitHub Issues

- nodejs/node-gyp#600: "gyp: name 'target_arch' is not defined"
- nodejs/node-gyp#2813: "Build defaults to x86 on a x64 Windows machine"
- prebuild/prebuildify#53: Changed from `--target-arch` to `--arch`

### Similar Projects

- node-sqlite3: Uses simpler binding.gyp without architecture defines
- node-canvas: Uses `WIN32_LEAN_AND_MEAN` but not architecture defines
- serialport: Focus on exception handling and warning suppression

## Why a Wrapper Header Won't Work

**Important Discovery**: A single `windows_compat.h` wrapper cannot solve this issue because:

1. At compile time, we can't distinguish between x64 and ARM64 (both define `_WIN64`)
2. The architecture information (`target_arch`) is only available in binding.gyp
3. Prebuildify doesn't properly pass the conditional defines from binding.gyp to the compiler

This means any compile-time logic would incorrectly set x64 defines on ARM64 builds or vice versa.

## Conclusion

The "No Target Architecture" error is a known limitation of how prebuildify and node-gyp handle Windows builds. The current workaround of adding architecture defines directly to source files is the most reliable solution.

**Why Other Projects Don't Have This Issue**:

- Projects like node-sqlite avoid `<windows.h>` by using cross-platform APIs
- Most Node.js addons don't directly interface with Windows system APIs

**The Solution**:
Use `scripts/prebuildify-wrapper.ts` which sets the CL environment variable with architecture-specific defines. This approach:

1. Works reliably with prebuildify
2. Correctly handles both x64 and ARM64 architectures
3. Doesn't require modifying source files
4. Avoids hardcoding architecture assumptions

## Next Steps

1. Consider opening an issue with prebuildify about Windows architecture detection
2. Test if explicit `--arch x64` flags to prebuildify resolve the issue
3. Investigate why other native modules don't encounter this problem
4. Consider if our include order or binding.gyp structure is unusual
